---
title: "eBird Sampling Effort Summaries ***** DRAFT *****"
author: "N.M. Tarr"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  rmdformats::downcute:
  html_document:
    df_print: paged
    code_folding: hide

---
# Purpose
This notebook summarizes eBird sampling (effort) within North Carolina for the past 5 years.  Sampling data can be downloaded from the eBird website and queried with eBird's R package named "auk".  The script named "filter_eBird_sampling.R", which is saved in the NCBA github repo, performs the filtering that supports this notebook.  

The records available from the sampling data set are for individual, unique checklists and several attributes are included for each.  This notebook summarizes the available attribute values to learn as much as possible about the modern eBird effort to date within North Carolina.  The available checklist attributes are:

checklist_id, last_edited_date, county, county_code, iba_code, bcr_code, 
usfws_code, atlas_block, locality, locality_id, locality_type, latitude,
longitude, observation_date, time_observations_started, observer_id, 
sampling_event_identifier, protocol_type, protocol_code, project_code, 
duration_minutes, effort_distance_km, effort_area_ha, number_observers,
all_species_reported, group_identifier, trip_comments   

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE)

library(auk)
library(tidyverse)
library(ggplot2)
theme_set(theme_bw())
library(sf)
library(RColorBrewer)
library(maps)
library(hms)
library(lubridate)
library(tmap)
starttime <- Sys.time()

comma <- function(x) format(x, digits=2, big.mark=",")
```

```{r block_data}
# Read in NCBA block spatial data frame
blocks_path <- "~/Data/ncba_blocks.shp"
blocks_sf <- st_read(blocks_path)

# We need to assign the crs to the blocks since none is in metadata, I asked 
# John Carpenter for which crs it is in.
st_crs(blocks_sf) = 6542
```

```{r checklists}
# Reference the filtered checklist output file
filtered_checklists <- "~/Documents/NCBA/Data/filtered_checklists.txt"

# Read in the effort data (filtered checklist table)
checklists <- read_sampling(filtered_checklists)

# Further filtering of the sampling data can occur here.  For example, we may
# want to remove data from certain projects.
```

```{r counties_data}
# Read in county spatial data frame
counties <- st_as_sf(map("county", plot = FALSE, fill = TRUE)) %>%
  subset(grepl("north carolina", ID)) %>%
  mutate(county = str_to_title(str_replace(ID, "north carolina,", ""))) %>%
  select(-c(ID))
# Reproject?
```

# General

* There are currently `r comma(length(unique(checklists$checklist_id)))` checklists from North Carolina in eBird.

# Week
```{r}
by_week <- checklists %>%
  mutate(week=week(date(observation_date))) %>%
  group_by(week) %>%
  summarize(count=n())

ggplot(data=by_week) +
  geom_line(mapping=aes(y=count, x=week), show.legend=TRUE, color="orange") + 
  labs(title="EBirder activity varies greatly throughout the year",
       caption="Checklists from before 2015 are not included") +
  ylab("total number of checklists") +
  scale_x_continuous(limits=c(0,52), breaks=seq(0,52,by=4)) +
  scale_y_continuous(breaks=seq(0,30000,5000))
```


# Locality
```{r group_by_locality}
by_locality <- checklists %>%
  group_by(locality, locality_id) %>%
  summarize(count = n())
```

* Many checklists are revisits to previously surveyed locations.  The ratio of locations that were visited once to the total number of checklists is `r round(nrow(filter(by_locality, count==1))  / length(unique(checklists$checklist_id)), digits=2)`.

* Most locations have only been sampled once.  However, some locations have been visited an enormous number of times.

```{r locality_boxplot}
ggplot(data=by_locality) +
  geom_boxplot(mapping=aes(y=count, x=""), color="blue", 
               outlier.colour="orange", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Some locations have been very heavily sampled",
       caption="Checklists from before 2015 are not included") +
  ylab("Checklists (n)") + 
  scale_y_continuous(n.breaks=12)
```

```{r locality_pie}
labels <- c("1", "2:10", "11:20", "21:5,000")
locality_bins <- table(cut(by_locality$count, breaks=c(0,1,10,20,5000),
                           labels=labels)) %>%
                  data.frame()
colnames(locality_bins) = c("times_surveyed", "value")

ggplot(data=locality_bins, aes(x="", y=value, fill=times_surveyed)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d(alpha = 1, option="D") +
  theme_void() + 
  labs(title="Most locations have only been sampled once",
       caption="Checklists from before 2015 are not represented")
```

```{r locality_type_pie}
# Summarize whether checklists are for hotspots, personal locations, etc.
by_locality_type <- checklists %>%
  group_by(locality_type) %>%
  summarize(
    count = n())

# Print pie chart
ggplot(data=by_locality_type, aes(x="", y=count, fill=locality_type)) +
  geom_bar(stat="identity", width=1) +
  coord_polar("y", start=0) +
  scale_fill_viridis_d(alpha = 1, option="D") +
  theme_void() + 
  labs(title="Many checklists are assigned to hotspots, but most are not",
       caption="Checklists from before 2015 are not represented")

# Print table
knitr::kable(by_locality_type, caption="Number of checklists per locality type")
```

## Most Visited Locations Table
```{r most_visited_locations}
most_visited <- by_locality %>%
  arrange(by=desc(count)) %>%
  filter(count > 99)

knitr::kable(most_visited, caption="Locations visited 100 or more times.")
```

# Spatial Distribution
```{r xy_locations}
ggplot(data=checklists) +
  geom_point(mapping=aes(y=latitude, x=longitude), color="darkgreen",
             shape=3) + 
  labs(title="Checklist locations are distributed throughout NC, but coverage is incomplete",
       caption="Checklists from before 2015 were not included in this summary") +
  ylab("latitude") + 
  xlab("longitude")
```

## Checklists per County
```{r per_county_bwplot}
by_county <- checklists %>%
  group_by(county) %>%
  summarize(
    count = n(),
  ) %>%
  arrange(county) 

# We will need median # checklists for below
median.checklists <- toString(comma(summary(by_county$count)[[3]]))

# Make a boxplot of checklists per county
ggplot(data=by_county) +
  geom_boxplot(mapping=aes(y=count, x=""), color="orange", 
               outlier.colour="darkred", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="A handful of counties have many more checklists than others",
       subtitle=str_c("The median number of checklists in a county was ",
                      median.checklists),
       caption="Checklists from before 2015 are not included") +
  ylab("Checklists (n)") + 
  scale_y_continuous(n.breaks=12)
```

Between `r comma(summary(by_county$count)[[1]])` and `r comma(summary(by_county$count)[[6]])` checklists are available for counties in North Carolina, and the median number of checklists is `r comma(summary(by_county$count)[[3]])`.

```{r per_county_map}
# Join to get the checklist count
counties.checklists <- counties %>%
  left_join(by_county, by = "county")

# Pull out just the column of interest here ("count") and plot it.
county.count <- select(counties.checklists, count, geom)
ggplot(data=county.count) +
  geom_sf(data=counties.checklists, aes(fill=count)) +
  scale_fill_viridis_c(trans = "sqrt", alpha = 1, option="E") +
  labs(title="Large variation exists in the number of checklists among counties",
       caption="Checklists from before 2015 are not included")
```

### Top 10 Counties
```{r top_county_table}
knitr::kable(head(arrange(by_county, desc(count)), n=10), caption="Top 10 Counties")
```

```{r top_county_map}
# Add a column to record whether it's a "top" or "bottom" county as far as count goes.
tops <- counties.checklists %>% arrange(desc(count)) %>% head(n=10)
bottoms <- counties.checklists %>% arrange(count) %>% head(n=10)
counties.checklists <- counties.checklists %>%
  mutate(top10 = ifelse(count %in% tops$count, TRUE, FALSE)) %>%
  mutate(bottom10 = ifelse(count %in% bottoms$count, TRUE, FALSE)) %>%
  arrange(desc(count))

# Pull out just the column of interest here ("count") and plot it.
tops2 <- counties.checklists %>%
  select(top10, geom)
ggplot() +
  geom_sf(data=tops2, aes(fill=top10)) +
  scale_fill_viridis_d(alpha = 1, option="D") +
  labs(title="Counties with large cities are heavily sampled",
       caption="Checklists from before 2015 are not included")
```

### Bottom 10 Counties
```{r bottom_county_table}
knitr::kable(head(arrange(by_county, count), n=10), caption="Bottom 10")
```

```{r bottom_county_map}
# Pull out just the column of interest here ("count") and plot it.
bottoms2 <- counties.checklists %>%
  select(bottom10, geom)
ggplot() +
  geom_sf(data=bottoms2, aes(fill=bottom10)) +
  scale_fill_viridis_d(alpha = 1, option="E") +
  labs(title="Counties with fewest checklists are in the Coastal Plains",
       caption="Checklists from before 2015 are not included")
```

### Checklists per County Table
Note, the assignment of checklists to counties was performed by eBird and it is possible that errors exist due to traveling counts that cross county lines and errors in the recorded locations of checklists.
```{r per_county_all}
knitr::kable(by_county, caption="")
```

## Checklists per Atlas Block
Although coordinates are provided by eBird for checklists, they do not provide precise locations of eBirder effort for two reasons.  First, there are limits to the spatial precision of the points due to gps precision and/or observers ability to identify exactly where they birded on a map or in the app.  Second, many birders travel while birding but their paths are not available, only the distances they traveled.

Locational uncertainty is important because if it is large in relation to the level of analysis, it creates uncertainty about which spatial subregions, such as counties or atlas blocks, a checklist should be attributed to.  One approach is to assign each checklist to the subregion that the checklist coordinate is located within.  That approach could generate deceptive results if checklists represent birding effort from multiple blocks but are assigned to a single block or if the coordinate is located in a block adjacent to where the birding actually occurred. I present results from this approach below for reference and coarse data summary and refer to it as "coordinate count".

Another approach is to use checklist polygons instead of the coordinates (points) in order to include the locational uncertainty in the summary.  Under this approach, coordinates are buffered with the distance traveled by the observer during the checklist period.  Each checklist is then assigned to all of the blocks that the polygon intersects in order to acknowledge that the checklist could represent effort from multiple blocks. Results from this approach can logically be expected to exaggerate the true footprint of birding effort and suggest blocks were sampled that actually were not.  The results are forthcoming.
```{r make_checklists_spatial}
# Create spatial frame of checklists data frame
checklists_sf <- checklists %>%
  st_as_sf(coords=c("longitude", "latitude"), crs=4326) %>%
  st_transform(6542)
```

```{r lists_per_block_coordinate}
# Add block info to checklists
checklist_plus_block <- st_join(checklists_sf, blocks_sf, join = st_within, 
                                left=TRUE) %>%
  select(-c(NAME, STATUS, COUNTY, FORM_LINK))

# Tally checklists per block
by_block_coord <- checklist_plus_block %>%
  group_by(BLOCK_NAME) %>%
  summarize(count=n())

# Join the tally with the block spatial frame to get zero blocks and support map
by_block_coord_count <- by_block_coord %>%
  select(BLOCK_NAME, count) %>%
  data.frame() %>%
  select(-c(geometry))

by_block_sf <- left_join(blocks_sf, by_block_coord_count, by=("BLOCK_NAME" = "BLOCK_NAME")) %>%
  select(BLOCK_NAME, count, geometry) %>%
  replace_na(list(count=0))
```

```{r lists_per_block_boxplot}
# Boxplot
ggplot(data=by_block_sf) +
  geom_boxplot(mapping=aes(y=count, x=""), color="blue", 
               outlier.colour="gold", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Many blocks have no checklists, but others have thousands",
       caption="Checklists from before 2015 are not included") +
  ylab("Checklists (n)") + 
  scale_y_continuous(n.breaks=12)
summary(by_block_sf$count)
```

```{r block-coordinate_tally_map}
# Get priority block centroids for plotting
priority_dots <- st_centroid(filter(blocks_sf, TYPE == "Priority")$geometry)

# Plot the map
tmap_mode("view")
tm_shape(by_block_sf) +
  tm_fill(
    col = "count",
    palette = "Blues",
    style="fixed",
    alpha = .6,
    breaks = c(0, 1, 50, 100, 1000, 2000, 10000),
    as.count = TRUE
  ) +
tm_shape(priority_dots) + 
  tm_dots(col="purple", size=0.01)
```

```{r blocks_with_most_coordinates}
# Sort blocks by number of checklist coordinates
top_blocks <- by_block_coord_count %>%
  arrange(desc(count)) %>%
  head(n = 20)

knitr::kable(top_blocks, caption="Blocks with checklist coordinate counts in the top 20")
```

```{r coordinate-block_count_bar}
by_block_sf$ysn_checklists <- ifelse(by_block_sf$count > 0, "Checklists",
                                     "No Checklists")

priority_blocks <- blocks_sf %>%
  data.frame() %>%
  filter(TYPE=="Priority") %>%
  select(BLOCK_NAME, TYPE) %>%
  left_join(data.frame(by_block_sf), by=("BLOCK_NAME" = "BLOCK_NAME"))
  
ggplot(data=priority_blocks, aes(ysn_checklists)) +
  geom_bar() +
  ylab("Priority Blocks") +
  xlab("") + 
  labs(title="A small proportion, but considerable number, of priority blocks remain unsampled",
       caption="Checklists from before 2015 are not included")
```


# Observers
## All observers
```{r observer_summary_stats}
by_observer <- checklists %>%
  group_by(observer_id) %>%
  summarize(
    count = n())
obs_summary <- by_observer$count %>%
  summary()
```

Most eBirders have only submitted a handful of checklists. The median number of checklists submitted is only `r obs_summary[[3]]`, and observers who have submitted more than `r obs_summary[[5]]` are in the top quartile for number of submissions.
```{r observer_boxplot}
ggplot(data=by_observer) +
  geom_boxplot(mapping=aes(y=count, x=""), color="darkgreen", 
               outlier.colour="blue", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Even moderately active eBirders are in the minority",
       caption="Checklists from before 2015 are not included") +
  ylab("Checklists (n)") + 
  scale_y_continuous(n.breaks=12)
```

## Core observers
It is informative to look more closely at a subset of active observers in order to better characterize observers who may participate in the atlas.  Here, I exclude the extreme outliers and people with fewer than some arbitrarily "small" number of submissions (20). 
```{r core_observer_stats}
core_observers <- by_observer %>%
  filter(count > 20 & count < 3000)
topobs_summary <- core_observers$count %>%
  summary()
```

```{r core_observer_boxplot}
ggplot(data=core_observers) +
  geom_boxplot(mapping=aes(y=count, x=""), color="darkgrey", 
               outlier.colour="darkred", show.legend=TRUE) + 
  coord_flip() + 
  labs(title='Most "core" eBirders have submitted < 100 checklists',
       caption="Checklists from before 2015 were not included in this summary") +
  ylab("Checklists (n)") + 
  scale_y_continuous(n.breaks=12)
```

# Protocol
```{r protocol}
# Summarize protocol
by_protocol <- checklists %>%
  group_by(protocol_type) %>%
  summarize(
    count = n())
colnames(by_protocol) = c("Protocol Type", "Checklists (n)")

# Print table
knitr::kable(by_protocol)
```

# Project
```{r project}
# Summarize projects
by_project <- checklists %>%
  group_by(project_code) %>%
  summarize(
    count = n())
colnames(by_project) = c("Project", "Checklists (n)")

# Print table
knitr::kable(by_project)
```

# Start Time
```{r time}
start_df <- checklists %>%
  select(time_observations_started) %>%
  mutate(time=hour(as_hms(time_observations_started)))

ggplot(data=start_df) +
  geom_boxplot(mapping=aes(y=time, x=""), color="darkblue", 
               outlier.colour="magenta", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="eBirders generally get out in the late morning",
       caption="Checklists from before 2015 are not included") +
  ylab("Start Hour") + 
  scale_y_continuous(n.breaks=12)
```

# Duration
```{r duration_prep}
# Prep a data frame of duration data
duration_df <- checklists %>%
  select(duration_minutes) %>% 
  arrange(desc(duration_minutes))

too_long <- subset(duration_df, duration_minutes > 1440)
sorta_long <- subset(duration_df, duration_minutes <1441 & duration_minutes > 720)
duration_OK <- subset(duration_df, duration_minutes < 721)
```

* The durations of most checklists are less than one day (1,440 minutes), but `r nrow(too_long)` checklists carried on longer than a day and `r nrow(sorta_long)` checklists lasted between 12 and 24 hours. 
* I omitted checklists longer than 12 hours for the summaries in this section.

```{r duration_boxplot}
ggplot(data=duration_OK) +
  geom_boxplot(mapping=aes(y=duration_minutes, x=""), color="purple", 
               outlier.colour="red", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Many checklists were over an hour long",
       caption="Checklists from before 2015 are not included") +
  ylab("Minutes") + 
  scale_y_continuous(n.breaks=12)
```

```{r duration_table}
print(summary(duration_OK$duration_minutes))
```

# Distance
```{r distance_prep}
# Prep a data frame of duration data
distance_df <- checklists %>%
  select(effort_distance_km) %>% 
  arrange(desc(effort_distance_km))

too_far <- subset(distance_df, effort_distance_km > 5)
distance_OK <- subset(distance_df, effort_distance_km < 6)
```


```{r distance_boxplot}
ggplot(data=distance_OK) +
  geom_boxplot(mapping=aes(y=effort_distance_km, x=""), color="darkgreen", 
               outlier.colour="blue", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Checklists with distances < 1km are in the minority",
       caption="Checklists from before 2015 are not included") +
  ylab("Kilometers") + 
  scale_y_continuous(n.breaks=12)
summary(distance_OK$effort_distance_km)
```

```{r too_far_boxplot}
ggplot(data=too_far) +
  geom_boxplot(mapping=aes(y=effort_distance_km, x=""), color="darkred", 
               outlier.colour="gold", show.legend=TRUE) + 
  coord_flip() + 
  labs(title="Most excessively long checklists are around 10km in length",
       caption="Checklists from before 2015 are not included") +
  ylab("Kilometers") + 
  scale_y_continuous(n.breaks=12)
summary(too_far$effort_distance_km)
```

# Runtime
```{r runtime}
endtime <- Sys.time()
runtime <- endtime - starttime
```
`r format(runtime)`